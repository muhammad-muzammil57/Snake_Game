<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Snake â€” Developed by Muzammil</title>
<style>
  html,body { height:100%; margin:0; background:#071028; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#fff; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; }
  #gameWrap { position:relative; width:100%; height:100vh; overflow:hidden; display:flex; align-items:center; justify-content:center; }
  canvas { background: linear-gradient(180deg,#041023,#07182a); display:block; width:100%; height:100%; }
  .hud {
    position:absolute; top:8px; left:0; right:0; display:flex; align-items:center; justify-content:space-between; padding:8px 16px; pointer-events:none;
    font-weight:700; letter-spacing:1px;
  }
  .title { pointer-events:none; font-size:18px; text-align:center; color:#ffd; }
  .panel { display:flex; gap:14px; align-items:center; pointer-events:none; }
  .stat { background:rgba(0,0,0,0.25); padding:6px 10px; border-radius:8px; font-size:14px; backdrop-filter: blur(6px); }
  .controls {
    position:absolute; bottom:14px; left:50%; transform:translateX(-50%); display:flex; gap:10px; pointer-events:auto;
    align-items:center;
  }
  .dpad, .action {
    display:grid; gap:8px;
  }
  .dpad { grid-template-columns: 56px 56px 56px; grid-template-rows: 56px 56px; }
  .btn {
    width:56px; height:56px; border-radius:10px; background:rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; font-weight:700; color:#fff; box-shadow: 0 4px 18px rgba(0,0,0,0.6);
    touch-action: none;
  }
  .btn:active { transform:scale(0.96); filter:brightness(0.98); }
  .hidden { display:none !important; }
  .overlay {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; z-index:20;
    pointer-events:none;
  }
  .winBox {
    background: rgba(0,0,0,0.6); padding:22px 28px; border-radius:12px; border:2px solid rgba(255,255,255,0.06);
    text-align:center; pointer-events:auto;
  }
  .big { font-size:32px; font-weight:900; letter-spacing:2px; }
  .small { font-size:16px; margin-top:8px; }
  canvas { touch-action: none; }
  @media (min-width:900px) {
    .controls { display:none; } 
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="panel left">
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="time">Time: 0s</div>
    </div>
    <div class="title">DEVELOPED BY MUZAMMIL</div>
    <div class="panel right">
      <div class="stat" id="best">Best: 0</div>
      <div class="stat" id="colorName">Color</div>
    </div>
  </div>

  <div class="controls" id="mobileControls" aria-hidden="true">
    <div class="dpad" id="dpad">
      <div></div>
      <button class="btn" id="btnUp">â–²</button>
      <div></div>
      <button class="btn" id="btnLeft">â—€</button>
      <button class="btn" id="btnDown">â–¼</button>
      <button class="btn" id="btnRight">â–¶</button>
    </div>
    <div class="action">
      <button class="btn" id="btnColor">R</button>
      <button class="btn" id="btnRestart">âŸ³</button>
    </div>
  </div>

  <div class="overlay" id="overlay" style="display:none;">
    <div class="winBox" id="winBox">
      <div class="big" id="winText">BHOOM YOU WIN ðŸŽ‰</div>
      <div class="small" id="winScore">Score: 0 â€” Time: 0s</div>
      <div style="margin-top:12px;"><button class="btn" id="winRestart"onclick="location.reload()">Play Again</button></div>
    </div>
  </div>

</div>

<script>
const CELL_SIZE = 20;          
const BASE_SPEED = 8;          
const COLORS = ['#3fe0c7','#7cf59b','#ffd166','#ff6b6b','#a86bff','#66a3ff','#ff9f1c']; 
const OBSTACLE_COUNT = 12;    
const FOOD_COUNT = 1;
const ENDPOINT_SIZE = 2;       
const WIN_SCORE = 10;         

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { willReadFrequently: false });
let width = 800, height = 600;
let cols = 40, rows = 30;
let scale = 1;

const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('time');
const bestEl = document.getElementById('best');
const colorNameEl = document.getElementById('colorName');
const overlay = document.getElementById('overlay');
const winText = document.getElementById('winText');
const winScore = document.getElementById('winScore');

let best = Number(localStorage.getItem('snake_best') || 0);
bestEl.textContent = 'Best: ' + best;

let snake = [];
let dir = {x:1, y:0}; 
let nextDir = {x:1,y:0};
let food = [];
let obstacles = [];
let endpoint = {x:0,y:0};
let snakeColorIndex = 0;
let snakeColor = COLORS[snakeColorIndex];
let score = 0;
let startTime = null;
let elapsed = 0;
let running = false;
let gameOver = false;
let win = false;
function resizeCanvas() {
  const wrap = document.getElementById('gameWrap');
  width = wrap.clientWidth;
  height = wrap.clientHeight;
  const minDim = Math.min(width, height);
  scale = Math.max(12, Math.floor(minDim / 40));
  cols = Math.max(12, Math.floor(width / scale));
  rows = Math.max(12, Math.floor(height / scale));
  canvas.width = cols * scale;
  canvas.height = rows * scale;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
}
window.addEventListener('resize', () => {
  resizeCanvas();
});

function cellToPx(c) { return c * scale; }

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function eq(a,b){ return a.x===b.x && a.y===b.y; }
function inBounds(p){ return p.x>=0 && p.x<cols && p.y>=0 && p.y<rows; }

function placeObstacles() {
  obstacles = [];
  const attempts = OBSTACLE_COUNT * 6;
  for (let i=0;i<OBSTACLE_COUNT;i++){
    const w = randInt(1, Math.min(6, Math.floor(cols/6)));
    const h = randInt(1, Math.min(4, Math.floor(rows/6)));
    let tries = 0;
    while(tries++ < attempts) {
      const x = randInt(2, cols - w - 3);
      const y = randInt(3, rows - h - 3);

      const rect = {x,y,w,h};
      if (!intersectsAny(rectToCells(rect), [...snake, ...food])) {
        obstacles.push(rect);
        break;
      }
    }
  }
}

function rectToCells(r){
  const arr=[];
  for(let xx=r.x; xx<r.x+r.w; xx++){
    for(let yy=r.y; yy<r.y+r.h; yy++){
      arr.push({x:xx,y:yy});
    }
  }
  return arr;
}

function intersectsAny(cells, items){
  for(const a of cells){
    for(const b of items){
      if (b && typeof b.x !== 'undefined' && a.x===b.x && a.y===b.y) return true;
    }
  }
  return false;
}

function placeFood(n=1){
  food = [];
  let tries = 0;
  while(food.length < n && tries++ < 1000){
    const p = {x: randInt(1, cols-2), y: randInt(3, rows-2)};
    if (occupied(p)) continue;
    food.push(p);
  }
}

function occupied(p){
  if (!inBounds(p)) return true;
  if (snake.some(s=>s.x===p.x && s.y===p.y)) return true;
  if (food.some(f=>f.x===p.x && f.y===p.y)) return true;
  for(const o of obstacles){
    if (p.x>=o.x && p.x<o.x+o.w && p.y>=o.y && p.y<o.y+o.h) return true;
  }
  for(let ex=endpoint.x; ex<endpoint.x+ENDPOINT_SIZE; ex++){
    for(let ey=endpoint.y; ey<endpoint.y+ENDPOINT_SIZE; ey++){
      if (p.x===ex && p.y===ey) return true;
    }
  }
  return false;
}

function placeEndpoint(){
  const candidates = [
    {x: cols - 4 - ENDPOINT_SIZE, y: 4},
    {x: 2, y: rows - 6 - ENDPOINT_SIZE},
    {x: cols - 6 - ENDPOINT_SIZE, y: rows - 6 - ENDPOINT_SIZE},
    {x: 2, y: 4}
  ];
  for(const c of candidates) {
    const rect = {x:c.x,y:c.y,w:ENDPOINT_SIZE,h:ENDPOINT_SIZE};
    if (!intersectsAny(rectToCells(rect), [...snake])) {
      endpoint = {x:c.x,y:c.y};
      return;
    }
  }
  let tries=0;
  while(tries++<1000){
    const x = randInt(2, cols-ENDPOINT_SIZE-3);
    const y = randInt(3, rows-ENDPOINT_SIZE-3);
    const rect = {x,y,w:ENDPOINT_SIZE,h:ENDPOINT_SIZE};
    if (!intersectsAny(rectToCells(rect), [...snake])) {
      endpoint = {x,y}; return;
    }
  }
}
function startGame(){
  resizeCanvas();
  snake = [];
  const startX = Math.floor(cols/4);
  const startY = Math.floor(rows/2);
  for(let i=0;i<5;i++) snake.push({x: startX - i, y: startY});
  dir = {x:1,y:0}; nextDir = {x:1,y:0};
  snakeColorIndex = 0; snakeColor = COLORS[snakeColorIndex];
  score = 0;
  startTime = performance.now();
  elapsed = 0;
  running = true;
  gameOver = false;
  win = false;
  placeObstacles();
  placeEndpoint();
  placeFood(FOOD_COUNT);
  overlay.style.display = 'none';
  colorNameEl.textContent = snakeColor;
  updateHUD();
  lastTick = performance.now();
}
window.addEventListener('keydown', (e)=>{
  if (!running && e.key===' '){ startGame(); return; }
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W'){ setDirection(0,-1); e.preventDefault(); }
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S'){ setDirection(0,1); e.preventDefault(); }
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){ setDirection(-1,0); e.preventDefault(); }
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){ setDirection(1,0); e.preventDefault(); }
  if (e.key === 'r' || e.key === 'R'){ changeColor(); e.preventDefault(); }
  if (e.key === 'Escape'){ running=false; showOverlay('Paused'); }
  if (e.key === 'F5') { }
});

function setDirection(x,y){
  
  if (x === -dir.x && y === -dir.y) return;
  nextDir = {x,y};
}
const btnUp = document.getElementById('btnUp');
const btnDown = document.getElementById('btnDown');
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnColor = document.getElementById('btnColor');
const btnRestart = document.getElementById('btnRestart');
const winRestart = document.getElementById('winRestart');

[btnUp,btnDown,btnLeft,btnRight].forEach((b, idx)=>{
  if(!b) return;
  b.addEventListener('touchstart', (ev)=>{ ev.preventDefault();
    if (b.id==='btnUp') setDirection(0,-1);
    if (b.id==='btnDown') setDirection(0,1);
    if (b.id==='btnLeft') setDirection(-1,0);
    if (b.id==='btnRight') setDirection(1,0);
  });
});

if (btnColor) btnColor.addEventListener('touchstart', (e)=>{ e.preventDefault(); changeColor(); });
if (btnRestart) btnRestart.addEventListener('touchstart', (e)=>{ e.preventDefault(); startGame(); });
if (winRestart) winRestart.addEventListener('click', ()=>startGame());

function changeColor(){
  snakeColorIndex = (snakeColorIndex + 1) % COLORS.length;
  snakeColor = COLORS[snakeColorIndex];
  colorNameEl.textContent = snakeColor;
  try {
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = 'sine';
    o.frequency.value = 440 + snakeColorIndex*60;
    g.gain.value = 0.02;
    o.connect(g); g.connect(ctxAudio.destination);
    o.start(); o.stop(ctxAudio.currentTime + 0.08);
  } catch(e){}
}

let lastTick = performance.now();
let acc = 0;
function gameLoop(now){
  if (!running) { requestAnimationFrame(gameLoop); return; }
  const dt = (now - lastTick) / 1000;
  lastTick = now;
  elapsed = (now - startTime)/1000;
  timeEl.textContent = 'Time: ' + Math.floor(elapsed) + 's';
  const speed = BASE_SPEED + Math.floor(score / 3);
  acc += dt * speed;
  while (acc >= 1) {
    tick();
    acc -= 1;
  }
  render();
  if (!gameOver && !win) requestAnimationFrame(gameLoop);
}

function tick(){
  dir = nextDir;
  const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
  if (!inBounds(head) || collideObstacles(head) || snake.slice(1).some(s=>s.x===head.x && s.y===head.y)){
    gameOver = true; running=false;
    showOverlay('Game Over');
    playDie();
    if (score > best){ best = score; localStorage.setItem('snake_best', best); bestEl.textContent = 'Best: '+best; }
    return;
  }
  snake.unshift(head);
  const ate = food.findIndex(f=>f.x===head.x && f.y===head.y);
  if (ate >= 0) {
    score += 1;
    scoreEl.textContent = 'Score: ' + score;
    food.splice(ate,1);
    placeFood(1);
    playEat();
  } else {
    snake.pop();
  }
  if (head.x >= endpoint.x && head.x < endpoint.x + ENDPOINT_SIZE &&
      head.y >= endpoint.y && head.y < endpoint.y + ENDPOINT_SIZE) {
    win = true; running = false;
    showWin();
    if (score > best){ best = score; localStorage.setItem('snake_best', best); bestEl.textContent = 'Best: '+best; }
    return;
  }
}

function collideObstacles(p){
  for(const o of obstacles) {
    if (p.x>=o.x && p.x < o.x + o.w && p.y>=o.y && p.y < o.y + o.h) return true;
  }
  return false;
}

function playEat(){
  try {
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = 'triangle';
    o.frequency.value = 880;
    g.gain.value = 0.02;
    o.connect(g); g.connect(ctxAudio.destination);
    o.start(); o.stop(ctxAudio.currentTime + 0.06);
  } catch(e){}
}
function playDie(){
  try {
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = 'sawtooth';
    o.frequency.value = 120;
    g.gain.value = 0.04;
    o.connect(g); g.connect(ctxAudio.destination);
    o.start(); o.stop(ctxAudio.currentTime + 0.18);
  } catch(e){}
}

function updateHUD(){ scoreEl.textContent = 'Score: ' + score; colorNameEl.textContent = snakeColor; timeEl.textContent = 'Time: 0s'; bestEl.textContent = 'Best: '+best; }

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, 'rgba(4,10,28,0.0)');
  g.addColorStop(1, 'rgba(4,10,28,0.08)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.fillStyle = '#ffd700';
  for(let ex=endpoint.x; ex<endpoint.x+ENDPOINT_SIZE; ex++){
    for(let ey=endpoint.y; ey<endpoint.y+ENDPOINT_SIZE; ey++){
      drawCell(ex,ey, '#ffd700', true);
    }
  }
  ctx.restore();

  ctx.save();
  for(const o of obstacles){
    ctx.fillStyle = 'rgba(255,255,255,0.98)';
    ctx.fillRect(cellToPx(o.x)+1, cellToPx(o.y)+1, cellToPx(o.w)-2, cellToPx(o.h)-2);
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(cellToPx(o.x)+1, cellToPx(o.y)+1, cellToPx(o.w)-2, Math.max(2, scale*0.18));
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = 1;
    ctx.strokeRect(cellToPx(o.x)+0.5, cellToPx(o.y)+0.5, cellToPx(o.w)-1, cellToPx(o.h)-1);
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(cellToPx(o.x)+1, cellToPx(o.y)+cellToPx(o.h)-2, cellToPx(o.w)-2, 2);
  }
  ctx.restore();

  for(const f of food){
    drawCell(f.x, f.y, '#ff4d6d', true);
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(cellToPx(f.x)+scale*0.25, cellToPx(f.y)+scale*0.15, scale*0.3, scale*0.25);
  }

  for(let i=snake.length-1;i>=0;i--){
    const p = snake[i];
    const t = i / snake.length;
    const col = i===0 ? lighten(snakeColor, -10) : snakeColor;
    drawCell(p.x, p.y, col, false, i===0);
  }

  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.font = Math.max(12, scale-2) + 'px system-ui';
  ctx.fillText('END', cellToPx(endpoint.x)+4, cellToPx(endpoint.y)+scale*0.7);
}

function drawCell(cx, cy, color, filled=true, head=false){
  const x = cellToPx(cx);
  const y = cellToPx(cy);
  if (filled) {
    ctx.fillStyle = color;
    roundRect(ctx, x+1, y+1, scale-2, scale-2, Math.max(3, scale*0.18), true, false);
    if (head) {
      // eye
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      const eyeX = x + (dir.x>0 ? scale*0.65 : dir.x<0 ? scale*0.18 : scale*0.5);
      const eyeY = y + (dir.y>0 ? scale*0.65 : dir.y<0 ? scale*0.18 : scale*0.5);
      ctx.fillRect(eyeX-2, eyeY-2, 4, 4);
    }
  } else {
    ctx.lineWidth = Math.max(1, scale*0.06);
    ctx.strokeStyle = color;
    ctx.shadowColor = 'rgba(0,0,0,0.12)';
    ctx.shadowBlur = Math.max(0, scale*0.6);
    roundRect(ctx, x+1, y+1, scale-2, scale-2, Math.max(3, scale*0.18), false, true);
    ctx.shadowBlur = 0;
  }
}
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}
function lighten(hex, amt) {
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num>>16) + amt; if (r>255) r=255; if (r<0) r=0;
  let g = ((num>>8)&0x00FF) + amt; if (g>255) g=255; if (g<0) g=0;
  let b = (num & 0x0000FF) + amt; if (b>255) b=255; if (b<0) b=0;
  return '#' + (r<<16 | g<<8 | b).toString(16).padStart(6,'0');
}

function showOverlay(msg){
  overlay.style.display = 'flex';
  document.getElementById('winText').textContent = msg;
  document.getElementById('winScore').textContent = 'Score: ' + score + ' â€” Time: ' + Math.floor(elapsed) + 's';
}

let fireworksParticles = [];
function showWin(){
  overlay.style.display = 'flex';
  winText.textContent = 'BHOOM YOU WIN ðŸŽ‰';
  winScore.textContent = 'Score: ' + score + ' â€” Time: ' + Math.floor(elapsed) + 's';
  startFireworks();
  playWinSound();
}

function startFireworks(){
  fireworksParticles = [];
  const canvasRect = canvas.getBoundingClientRect();
  const cx = canvas.width;
  const cy = canvas.height;
  let bursts = 0;
  const burstInterval = setInterval(()=>{
    if (bursts++ > 10) { clearInterval(burstInterval); return; }
    const bx = randInt(Math.floor(cx*0.2), Math.floor(cx*0.85));
    const by = randInt(Math.floor(cy*0.1), Math.floor(cy*0.6));
    createBurst(bx,by);
  }, 300);
  let fwLast = performance.now();
  function fwLoop(now){
    const dt = (now - fwLast)/1000; fwLast = now;
    for(let i=fireworksParticles.length-1;i>=0;i--){
      const p = fireworksParticles[i];
      p.vy += 80 * dt;
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) fireworksParticles.splice(i,1);
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for(const p of fireworksParticles){
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.max(0, p.life/1.6);
      ctx.fillRect(p.x-1, p.y-1, 3, 3);
    }
    ctx.restore();
    if (fireworksParticles.length > 0) {
      requestAnimationFrame(fwLoop);
    }
  }
  requestAnimationFrame(fwLoop);
}
function createBurst(x,y){
  const colors = ['#ff4d6d','#ffd166','#66a3ff','#7cf59b','#a86bff','#ffc75f'];
  for(let i=0;i<120;i++){
    const ang = Math.random()*Math.PI*2;
    const speed = Math.random()*220 + 80;
    fireworksParticles.push({
      x:x, y:y,
      vx: Math.cos(ang)*speed,
      vy: Math.sin(ang)*speed*-1,
      life: 1 + Math.random()*0.8,
      color: colors[randInt(0,colors.length-1)]
    });
  }
}
function playWinSound(){
  try {
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = 'sine';
    o.frequency.value = 660;
    g.gain.value = 0.03;
    o.connect(g); g.connect(ctxAudio.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(200, ctxAudio.currentTime + 0.6);
    g.gain.exponentialRampToValueAtTime(0.0001, ctxAudio.currentTime + 0.8);
    o.stop(ctxAudio.currentTime + 0.82);
  } catch(e){}
}

resizeCanvas();
startGame();
requestAnimationFrame(gameLoop);

let touchStart = null;
canvas.addEventListener('touchstart', (e)=>{
  if (e.touches.length === 1) {
    touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY, t:performance.now()};
  }
}, {passive:false});
canvas.addEventListener('touchend', (e)=>{
  if (!touchStart) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStart.x;
  const dy = touch.clientY - touchStart.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if (Math.max(adx,ady) > 30){
    if (adx > ady) setDirection(dx>0?1: -1, 0);
    else setDirection(0, dy>0?1:-1);
  } else {
    const w = window.innerWidth;
    if (touch.clientX > w*0.75) changeColor();
    else if (touch.clientX < w*0.25) startGame();
  }
  touchStart = null;
}, {passive:false});

function detectTouchControls(){
  const mc = document.getElementById('mobileControls');
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    mc.style.display = 'flex';
  } else {
    mc.style.display = 'none';
  }
}
detectTouchControls();

(function initBest(){
  bestEl.textContent = 'Best: ' + best;
})();

</script>
</body>
</html>
